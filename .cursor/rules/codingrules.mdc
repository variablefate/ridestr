---
description: Rules to follow while coding
globs: 
alwaysApply: true
---
#Coding Pattern Preferences

-- Always prefer simple solutions
- Avoid duplication of code whenever possible which means checking for other areas of the codebase that might already have similar code and functionality
- Write code that takes into account the different environments: dev, test, and prod
- You are careful to only make changes that are requested or you are confident are well understood and related to the change being requested
- When fixing an issue or bug, do not introduce a new pattern or technology without first exhausting all options for the existing implementation. And if you finally do this, make sure to remove the old implementation afterwards so we don't have duplicate logic.
- Keep the codebase very clean and organized
- Avoid writing scripts in files if possible, especially if the script is likely only to be run once
- Avoid having files over 200-300 lines of code. Refactor at that point.
- Mocking data is only needed for tests, never mock data for dev or prod
- Never add stubbing or fake data patterns to code that affects the dev or prod environments
- Never overwrite my .env file without first asking and confirming
- document your codewith clear comments and documentation
- Follow the principle of least astonishment
- Use consistent naming conventions
- Avoid global state if possible

#NIP Implementation Rules

- Follow the package naming convention: `com.vitorpamplona.quartz.nip<number>[description]`
- Maintain a clear separation between NIP specs (what the protocol requires) and implementation details
- Use consistent data types across the implementation:
  - If a NIP uses location data, use a single consistent Location class
  - For handling JSON content, define clear data classes that reflect the content structure
- When working with external libraries (like GraphHopper):
  - Create clear conversion methods between NIP data types and library data types
  - Keep conversion logic in dedicated utility methods
- For event handling:
  - Register all events for a NIP in a single initialization function
  - Ensure proper error handling with appropriate logging
- Follow the established pattern for each type of event class:
  - Each event type should have its own class extending Event
  - Use companion objects for constants and factory methods
  - Implement clear getContent() methods for parsing JSON content
- When adding a NIP to an existing codebase:
  - Ensure backwards compatibility with existing NIPs
  - Add comprehensive tests for new functionality
  - Document the implementation with KDoc comments

#Coding Workflow preferences

- Focus on the areas of code relevant to the task
- Do not touch code that is unrelated to the task
- Write thorough tests for all new features and bug fixes
- Avoid making major changes to the patterns and architecture of how a feature works, after it has shown to work well, unless explicitly structed
- Always think about what other methods and areas of code might be affected by code changes
- Use version control effectively - Frequent commits with clear messages, feature branches, and a stable main branch
